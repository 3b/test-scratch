name: CI
on:
  push:
    branches: [ master, scratch ]
  pull_request:
    branches: [ master ]

jobs:
  test:
    name: ${{ matrix.lisp }} on ${{ matrix.os }}
    strategy:
      matrix:
        lisp: [sbcl-bin]
        os: [ubuntu-latest,windows-latest]
      fail-fast: false

    runs-on: ${{ matrix.os }}
    defaults:
      run:
        # specify shell explicitly to get msys instead of git-bash on windows
        # shell: bash --login -eo pipefail "{0}"
        shell: ${{ fromJSON('[ "bash -leo pipefail", "msys2" ]') [ matrix.os == 'windows-latest' ] }} "{0}"

    steps:
    - uses: msys2/setup-msys2@v2
      if: matrix.os == 'windows-latest'
      with:
        path-type: minimal
        msystem: MINGW64
        release: false
        update: false

    - name: windows specific settings
      # run with powershell so it sets the git config used by actions/checkout
      shell: pwsh
      if: matrix.os == 'windows-latest'
      run: |
        git config --global core.autocrlf false
        git config --global core.eol lf
        # make sure MSYSCON is set so roswell doesn't try to install msys
        echo "MSYSCON=defterm" | Out-File -FilePath $env:GITHUB_ENV -Append
        # roswell installs to windows profile dir, so add to PATH using
        # pwsh $HOME also
        echo "$HOME/.roswell/bin" | Out-File -FilePath $env:GITHUB_PATH -Append
        # not sure what makes roswell install things here
        echo "$HOME/.roswell/lisp/quicklisp/bin" | Out-File -FilePath $env:GITHUB_PATH -Append
        echo home = $HOME
        echo userprofile = $USERPROFILE

    - uses: actions/checkout@v2
      # check out into subdir so we can pull other projects next to it.
      # roswell CI script sets up current dir as asdf search tree
      with:
        path: test-scratch

    - name: ci-utils fork
      uses: actions/checkout@v2
      with:
        repository: 3b/ci-utils
        ref: test2
        path: ci-utils

    - name: Print system version
      run: |
        uname

    - name: caches
      run: |
        echo cache key = ${{ env.cache-key }}
        echo ${{ runner.os }}-${{ matrix.lisp }}-dot-roswell-${{ hashFiles('**/*.asd') }}


    - name: cache .roswell
      id: cache-dot-roswell
      uses: actions/cache@v1
      with:
        path: ~/.roswell
        key: ${{ runner.os }}-${{ matrix.lisp }}-dot-roswell-${{ hashFiles('**/*.asd') }}
        restore-keys: ${{ runner.os }}-${{ matrix.lisp }}-dot-roswell-

    - name: install roswell
      # always run install, since it does some global installs and setup that isn't cached
      env:
       LISP: ${{ matrix.lisp }}
      run: curl -L https://raw.githubusercontent.com/roswell/roswell/master/scripts/install-for-ci.sh | sh -x

    - name: install ci-utils
      run: |
        ros install ci-utils
        echo "$HOME/.roswell/bin" >> $GITHUB_PATH
        echo "$HOME/.roswell/bin"
        # we specified a login shell above, so use bash_profile to define
        # a test wrapper function for tests below
        cat <<"EOF" > ~/.bash_profile
        echo "loading functions"
        if [ -z $MSYSCON ] ; then
           CI_UTILS=$GITHUB_WORKSPACE/ci-utils
        else
           CI_UTILS=$(cygpath $GITHUB_WORKSPACE)/ci-utils
        fi
        RUN=$CI_UTILS/roswell/run-test-forms.ros
        # arbitrary exit code we tell lisp code to use to signal success
        PASS=33
        # value we expect on "successful" run of a test, usually $PASS
        # unless the test isn't expected to return normally from the
        # lisp code
        EXPECT=$PASS
        run_tests () {
          # passes arguments to run-test-forms, so use like
          # run_tests -l system (form)
          echo "$RUN $*"
          # run in a subshell to minimize scope of +e
          ( set +e
            $RUN -r $PASS "$@"
            local RET=$?
            set -e
            if [ $RET -eq $EXPECT ]
            then
              echo -e "\033[0;32mGot $RET, expected $EXPECT: OK\033[0m"
              true
            else
              echo -e "\033[0;31mGot $RET, expected $EXPECT: BAD $fail\033[0m"
              false
            fi
          )
        }
        EOF

    - name: run lisp
      continue-on-error: true
      run: |
        echo 1
        echo "path=$PATH"
        ros -e '(format t "~a:~a on ~a~%...~%~%" (lisp-implementation-type) (lisp-implementation-version) (machine-type))'
        echo 3
        ros -e '(format t " fixnum bits:~a~%" (integer-length most-positive-fixnum))'
        ros -e "(format t \"tf = ~s~%\" (ql:where-is-system 'trivial-features))"
        ros -e "(format t \"pngload= ~s~%\" (ql:where-is-system 'pngload))"
        ros -e '(format t "init features = ~s~%" *features*)'
        ros -e "(ql:quickload 'trivial-features)" -e '(format t "features = ~s~%" *features*)'

    - name: clear fasl cache
      run: |
        [ -d "$USERPROFILE/AppData/Local/cache/common-lisp/" ] && rm -rf $USERPROFILE/AppData/Local/cache/common-lisp/
        [ -d "~/.cache/common-lisp/" ] && rm -rf ~/.cache/common-lisp/
        mkdir -p ~/.cache/common-lisp/

    - name: fail
      run: |
        EXPECT=1 run_tests -l testing123 "(testing123:fail)"
        EXPECT=2 run_tests -l testing123 "(testing123:err)"

    - name: fail
      run: |
        EXPECT=1 run_tests -l testing123 "(testing123:fail)"
        EXPECT=2 run_tests -l testing123 "(testing123:err)"
        run_tests -l testing123 "(testing123:pass)"
        # try a form with spaces
        run_tests -l testing123 "(and (testing123:pass) t)"

    - name: load code from clean fasl cache
      run: |
        run_tests -l testing123 "(testing123:pass)"

    - name: load code from fasl
      run: |
        run_tests -l testing123 "(testing123:pass)"

    - name: fail
      run: |
        EXPECT=4 run_tests -h
        EXPECT=1 run_tests -l testing123 "(testing123:fail)"
        EXPECT=2 run_tests -l testing123 "(testing123:err)"


